// seedUsers.test.ts
import { AppDataSource } from '../../src/database/DataSource';
import { createInitialUsers, runMigrations } from '../../src/database/seeds/seedUsers';
import { SystemUser } from '../../src/models/';
import bcrypt from 'bcrypt';

jest.mock('../../src/database/DataSource');
jest.mock('bcrypt');

describe('User Seeder', () => {
  const mockUserRepository = {
    findOneBy: jest.fn(),
    save: jest.fn(),
  };

  beforeEach(() => {
    AppDataSource.getRepository = jest.fn().mockReturnValue(mockUserRepository);
    mockUserRepository.findOneBy.mockClear();
    mockUserRepository.save.mockClear();
  });

  describe('createInitialUsers', () => {
    it('should add new users when they do not already exist', async () => {
      mockUserRepository.findOneBy.mockResolvedValue(null);  // No user found
      await createInitialUsers();

      expect(mockUserRepository.save).toHaveBeenCalledTimes(10);  // Expect 10 new users to be saved
    });

    it('should skip adding users when they already exist', async () => {
      mockUserRepository.findOneBy.mockResolvedValue(new SystemUser("Alice", "alice@example.com", "hashed_password", "admin"));
      await createInitialUsers();

      expect(mockUserRepository.save).not.toHaveBeenCalled();  // No new user should be saved
    });

    it('should hash passwords correctly', async () => {
      mockUserRepository.findOneBy.mockResolvedValue(null);
      const hashSpy = jest.spyOn(bcrypt, 'hash');
      await createInitialUsers();

      expect(hashSpy).toHaveBeenCalledTimes(10);  // Hash should be called for each user
      expect(hashSpy).toHaveBeenCalledWith(expect.any(String), 10);  // Check hash function called with right parameters
    });
  });

  describe('runMigrations', () => {
    it('should run migrations successfully', async () => {
        const migrationsSpy = jest.spyOn(AppDataSource, 'runMigrations').mockResolvedValue([
        { id: 1, name: 'TestMigration', timestamp: new Date().getTime() }
        ]);
        await runMigrations();
    

      expect(migrationsSpy).toHaveBeenCalled();
      expect(console.log).toHaveBeenCalledWith('1 migration(s) executed.');
    });

    it('should handle errors during migrations', async () => {
      const error = new Error('Migration failed');
      jest.spyOn(AppDataSource, 'runMigrations').mockRejectedValue(error);

      await expect(runMigrations()).rejects.toThrow('Migration failed');
    });
  });

  describe('Data Source Initialization and Destruction', () => {
    it('should initialize data source and run seeder functions', async () => {
      //jest.spyOn(AppDataSource, 'initialize').mockResolvedValue(void 0);
      jest.spyOn(AppDataSource, 'destroy').mockResolvedValue();

      await expect(async () => {
        AppDataSource.initialize().then(() => {
          console.log("Data Source has been initialized!");
          runMigrations().then(() => {
            createInitialUsers().then(() => {
              console.log("Seeding completed!");
              AppDataSource.destroy();
            });
          });
        });
      }).not.toThrow();
    });

    it('should handle initialization errors', async () => {
      const error = new Error('Initialization failed');
      jest.spyOn(AppDataSource, 'initialize').mockRejectedValue(error);

      await expect(AppDataSource.initialize()).rejects.toThrow('Initialization failed');
    });
  });
});
